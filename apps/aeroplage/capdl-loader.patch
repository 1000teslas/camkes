#
# Copyright 2016, NICTA
#
# This software may be distributed and modified according to the terms of
# the BSD 2-Clause license. Note that NO WARRANTY is provided.
# See "LICENSE_BSD2.txt" for details.
#
# @TAG(NICTA_BSD)
#

diff --git a/capdl-loader-app/src/main.c b/capdl-loader-app/src/main.c
index edd7a3c..85adeb8 100644
--- a/capdl-loader-app/src/main.c
+++ b/capdl-loader-app/src/main.c
@@ -494,6 +494,38 @@ elf_load_frames(const char *elf_name, CDL_ObjID pd, CDL_Model *spec,
             elf64_getProgramHeaderTable(elf_file)[i].p_type = PT_NULL;
         }
     }
+
+    /* XXX: Hack to map the BGA frame buffer into the VESA driver's address
+     * space. We need this because CAmkES does not currently support large
+     * frame MMIO regions.
+     */
+    if (!strcmp(elf_name, "vesa.group.bin")) {
+        static int done = 0;
+        if (!done) {
+            uintptr_t bga_addr = 0xfd000000; // Physical address of the frame buffer
+            uintptr_t bga_vaddr = 0x400000; // Virtual address through which the VESA driver will access it
+            printf("Mapping BGA frame, %p\n", (void*)bga_addr);
+            for (unsigned int i = 0; i < bootinfo->numDeviceRegions; i++) {
+                uintptr_t paddr = bootinfo->deviceRegions[i].basePaddr;
+                int size = bootinfo->deviceRegions[i].frameSizeBits;
+                int frames = bootinfo->deviceRegions[i].frames.end
+                    - bootinfo->deviceRegions[i].frames.start;
+                for (unsigned int j = 0; j < frames; j++) {
+                    if (paddr + (1 << size) * j == bga_addr) {
+                        seL4_CPtr sel4_pd = orig_caps(pd);
+                        int err = seL4_ARCH_Page_Map(bootinfo->deviceRegions[i].frames.start + j,
+                            sel4_pd, bga_vaddr, seL4_AllRights, CDL_VM_CacheDisabled);
+                        assert(err == 0);
+                        goto found;
+                    }
+                }
+            }
+            printf("not found!\n");
+            assert(0);
+found:
+            done = 1;
+        }
+    }
 }
 
 /* Sort the untyped objects from largest to smallest.
